#include<iostream>
using namespace std;

long long dp[66][67][2]; //dp[i][j][k]，總共i個櫃子、j個處於安全狀態、最上層有沒有鎖(0 == 沒鎖，1 == 有鎖)

int main()
{
	dp[1][0][0] = dp[1][1][1] = 1; //在只有一個櫃子的情況下，0個安全必定沒鎖，1個安全則必定有鎖
	for (int i = 2; i <= 65; i++)
	{
		//若要在上層加1層沒鎖的櫃子，且0個櫃子安全的方法數 == i - 1個櫃子中，沒有一個安全且最上面沒鎖 + 1個安全且最上面的櫃子有鎖
		dp[i][0][0] = dp[i - 1][0][0] + dp[i - 1][1][1];
		for (int j = 1; j <= i; j++)
		{
			//若要在上層加1層沒鎖的櫃子，且使得有j個櫃子安全，則方法數 == 共i - 1層的櫃子中，j個安全且最上層沒鎖，加上j + 1個安全但最上層有鎖
			dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j + 1][1]; //極限情況：dp[65 - 1][65 + 1][1]，所以dp的第2格陣列要開67格
			//若要在上層加1層有鎖的櫃子，且使得有j個櫃子安全，則方法數 == 共i - 1層的櫃子且有j - 1個櫃子安全
			dp[i][j][1] = dp[i - 1][j - 1][0] + dp[i - 1][j - 1][1];
		}
	}

	for (int num, safe; cin >> num >> safe, num >= 0; cout << dp[num][safe][0] + dp[num][safe][1] << "\n");
	system("pause");
}